// Autogenerated from Pigeon (v22.7.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#include "messages.g.h"

struct _PigeonMelodinkMessageCodec {
  FlStandardMessageCodec parent_instance;

};

G_DEFINE_TYPE(PigeonMelodinkMessageCodec, pigeon_melodink_message_codec, fl_standard_message_codec_get_type())

static gboolean pigeon_melodink_message_codec_write_value(FlStandardMessageCodec* codec, GByteArray* buffer, FlValue* value, GError** error) {
  if (fl_value_get_type(value) == FL_VALUE_TYPE_CUSTOM) {
    switch (fl_value_get_custom_type(value)) {
    }
  }

  return FL_STANDARD_MESSAGE_CODEC_CLASS(pigeon_melodink_message_codec_parent_class)->write_value(codec, buffer, value, error);
}

static FlValue* pigeon_melodink_message_codec_read_value_of_type(FlStandardMessageCodec* codec, GBytes* buffer, size_t* offset, int type, GError** error) {
  switch (type) {
    default:
      return FL_STANDARD_MESSAGE_CODEC_CLASS(pigeon_melodink_message_codec_parent_class)->read_value_of_type(codec, buffer, offset, type, error);
  }
}

static void pigeon_melodink_message_codec_init(PigeonMelodinkMessageCodec* self) {
}

static void pigeon_melodink_message_codec_class_init(PigeonMelodinkMessageCodecClass* klass) {
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->write_value = pigeon_melodink_message_codec_write_value;
  FL_STANDARD_MESSAGE_CODEC_CLASS(klass)->read_value_of_type = pigeon_melodink_message_codec_read_value_of_type;
}

static PigeonMelodinkMessageCodec* pigeon_melodink_message_codec_new() {
  PigeonMelodinkMessageCodec* self = PIGEON_MELODINK_MESSAGE_CODEC(g_object_new(pigeon_melodink_message_codec_get_type(), nullptr));
  return self;
}

struct _PigeonMelodinkMelodinkHostPlayerApiInfo {
  GObject parent_instance;

  FlBinaryMessenger* messenger;
  gchar *suffix;
};

G_DEFINE_TYPE(PigeonMelodinkMelodinkHostPlayerApiInfo, pigeon_melodink_melodink_host_player_api_info, G_TYPE_OBJECT)

static void pigeon_melodink_melodink_host_player_api_info_dispose(GObject* object) {
  PigeonMelodinkMelodinkHostPlayerApiInfo* self = PIGEON_MELODINK_MELODINK_HOST_PLAYER_API_INFO(object);
  g_clear_object(&self->messenger);
  g_clear_pointer(&self->suffix, g_free);
  G_OBJECT_CLASS(pigeon_melodink_melodink_host_player_api_info_parent_class)->dispose(object);
}

static void pigeon_melodink_melodink_host_player_api_info_init(PigeonMelodinkMelodinkHostPlayerApiInfo* self) {
}

static void pigeon_melodink_melodink_host_player_api_info_class_init(PigeonMelodinkMelodinkHostPlayerApiInfoClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = pigeon_melodink_melodink_host_player_api_info_dispose;
}

PigeonMelodinkMelodinkHostPlayerApiInfo* pigeon_melodink_melodink_host_player_api_info_new(FlBinaryMessenger* messenger, const gchar* suffix) {
  PigeonMelodinkMelodinkHostPlayerApiInfo* self = PIGEON_MELODINK_MELODINK_HOST_PLAYER_API_INFO(g_object_new(pigeon_melodink_melodink_host_player_api_info_get_type(), nullptr));
  self->messenger = FL_BINARY_MESSENGER(g_object_ref(messenger));
  self->suffix = suffix != nullptr ? g_strdup_printf(".%s", suffix) : g_strdup("");
  return self;
}

struct _PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse {
  GObject parent_instance;

  FlValue* error;
};

G_DEFINE_TYPE(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse, pigeon_melodink_melodink_host_player_api_info_external_pause_response, G_TYPE_OBJECT)

static void pigeon_melodink_melodink_host_player_api_info_external_pause_response_dispose(GObject* object) {
  PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self = PIGEON_MELODINK_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(object);
  g_clear_pointer(&self->error, fl_value_unref);
  G_OBJECT_CLASS(pigeon_melodink_melodink_host_player_api_info_external_pause_response_parent_class)->dispose(object);
}

static void pigeon_melodink_melodink_host_player_api_info_external_pause_response_init(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self) {
}

static void pigeon_melodink_melodink_host_player_api_info_external_pause_response_class_init(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponseClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = pigeon_melodink_melodink_host_player_api_info_external_pause_response_dispose;
}

static PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* pigeon_melodink_melodink_host_player_api_info_external_pause_response_new(FlValue* response) {
  PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self = PIGEON_MELODINK_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(g_object_new(pigeon_melodink_melodink_host_player_api_info_external_pause_response_get_type(), nullptr));
  if (fl_value_get_length(response) > 1) {
    self->error = fl_value_ref(response);
  }
  return self;
}

gboolean pigeon_melodink_melodink_host_player_api_info_external_pause_response_is_error(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self) {
  g_return_val_if_fail(PIGEON_MELODINK_IS_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(self), FALSE);
  return self->error != nullptr;
}

const gchar* pigeon_melodink_melodink_host_player_api_info_external_pause_response_get_error_code(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self) {
  g_return_val_if_fail(PIGEON_MELODINK_IS_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(self), nullptr);
  g_assert(pigeon_melodink_melodink_host_player_api_info_external_pause_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 0));
}

const gchar* pigeon_melodink_melodink_host_player_api_info_external_pause_response_get_error_message(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self) {
  g_return_val_if_fail(PIGEON_MELODINK_IS_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(self), nullptr);
  g_assert(pigeon_melodink_melodink_host_player_api_info_external_pause_response_is_error(self));
  return fl_value_get_string(fl_value_get_list_value(self->error, 1));
}

FlValue* pigeon_melodink_melodink_host_player_api_info_external_pause_response_get_error_details(PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* self) {
  g_return_val_if_fail(PIGEON_MELODINK_IS_MELODINK_HOST_PLAYER_API_INFO_EXTERNAL_PAUSE_RESPONSE(self), nullptr);
  g_assert(pigeon_melodink_melodink_host_player_api_info_external_pause_response_is_error(self));
  return fl_value_get_list_value(self->error, 2);
}

static void pigeon_melodink_melodink_host_player_api_info_external_pause_cb(GObject* object, GAsyncResult* result, gpointer user_data) {
  GTask* task = G_TASK(user_data);
  g_task_return_pointer(task, result, g_object_unref);
}

void pigeon_melodink_melodink_host_player_api_info_external_pause(PigeonMelodinkMelodinkHostPlayerApiInfo* self, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data) {
  g_autoptr(FlValue) args = fl_value_new_list();
  g_autofree gchar* channel_name = g_strdup_printf("dev.flutter.pigeon.pigeon_melodink.MelodinkHostPlayerApiInfo.externalPause%s", self->suffix);
  g_autoptr(PigeonMelodinkMessageCodec) codec = pigeon_melodink_message_codec_new();
  FlBasicMessageChannel* channel = fl_basic_message_channel_new(self->messenger, channel_name, FL_MESSAGE_CODEC(codec));
  GTask* task = g_task_new(self, cancellable, callback, user_data);
  g_task_set_task_data(task, channel, g_object_unref);
  fl_basic_message_channel_send(channel, args, cancellable, pigeon_melodink_melodink_host_player_api_info_external_pause_cb, task);
}

PigeonMelodinkMelodinkHostPlayerApiInfoExternalPauseResponse* pigeon_melodink_melodink_host_player_api_info_external_pause_finish(PigeonMelodinkMelodinkHostPlayerApiInfo* self, GAsyncResult* result, GError** error) {
  g_autoptr(GTask) task = G_TASK(result);
  GAsyncResult* r = G_ASYNC_RESULT(g_task_propagate_pointer(task, nullptr));
  FlBasicMessageChannel* channel = FL_BASIC_MESSAGE_CHANNEL(g_task_get_task_data(task));
  g_autoptr(FlValue) response = fl_basic_message_channel_send_finish(channel, r, error);
  if (response == nullptr) { 
    return nullptr;
  }
  return pigeon_melodink_melodink_host_player_api_info_external_pause_response_new(response);
}
